Polymorphism:Temel sınıftan, türetilmiş sınıfa kalıtım yoluyla aktarılan,
fakat türetilmiş sınıfta farklı bir şekilde kullanılabilmesine izin verilen sınıf üyesi, çok biçimli bir üyedir.



-Compile-time/early binding/static binding 
-Run-time/late binding/ dynamic binding 

Run-time polymorphism= being able to assign different meanings to the same function at run-time.
Run-time polymorphism= Function Overriding 

Compile-time polymorphism= function overloading and operator overloading

*************************
A NON POLYMORPHIC EXAMPLE
*************************

Account a;
a.withdraw(1000);   //Account::withdraw();

Savings b;
b.withdraw(1000);   //Savings::withdraw();

Checking c;
c.withdraw(1000);   //Checking::withdraw();

Trust d;
d.withdraw(1000);   //Checking::withdraw();

For dynamic polymorphism we must have: Inheritance, Base Class Pointer or base class reference, virtual functions.

************************
using base class pointer
************************

Account *p1=new Account()
Account *p2=new Savings()
Account *p3=new Checking()
Account *p4=new Trust()

Declaring virtual functions
-Declare function you want to override as virtual in the base class 
-Dynamic polymorphism only via Account class pointer or reference

class Account{
      public:
             virtual void withdraw(double amount);
            };
            
 Override the function in the Derived classes 
 
 class Checking: public Account{
       public:
              virtual void withdraw(double amount);
              };
              
 **********************
 Polymorphism Challenge
 **********************
 
 You are provided with a completed Account class hierarchy that was completed in section1.
 the provided class hierarchy does not use dynamic polymorphism.
 
 Your challange is the following:
 
 1) Modify the account class so that it is now an Abstract class by adding the following pure virtual functions.
    virtual bool deposit(double amount);
    virtual bool withdraw(double amount);
    
 2) Create an I_Printable class interface as we did in the course and provide functionality so all accounts are printable to an ostream using the overloaded 
    insertion operator.
    
    class I_Printable 
    { 
       friend std::ostream &operator<< (std::ostream &os, const I_Printable &obj);
       public:
             .....
             
  3)Modify the functions in the Account_Util files so we only have one version of each.For example;
    
       


p1-> withdraw(1000);
p2-> withdraw(1000);
p3-> withdraw(1000);
p4-> withdraw(1000);

-----------------------------

Account *p1=new Account()
Account *p2=new Savings()
Account *p3=new Checking()
Account *p4=new Trust()

Account *array[]={p1,p2,p3,p4};
for (auto i=0; i<4; i++)
    array[i]->withdraw(1000);
-----------------------------

Account *p1=new Account()
Account *p2=new Savings()
Account *p3=new Checking()
Account *p4=new Trust()

vector<Account *> accounts
      {p1,p2,p3,p4};
      
for (auto acc ptr: accounts)
    acc_ptr->withdraw();
    
  **********************
  polymorphsim challange
  **********************
  
  you are provided with a completed Account class hierarchy that was completed in Section1.
  provided class hierarchy does not use dynamic polymorphism(it has no virtual function)
  
  Your challenge is the following:
  
  1. Modify the account class so that it is now an Abstaract class by adding the following pure virtual functions:
     virtual bool deposit(double amount)=0;
     virtual bool withdraw(double amount)=0;
     
  2.Create an I_Printable class interface as we did in the course and provide functionality so all accounts are printable to an ostream using
  overloaded insertion operator.
  
  3.Modify the functions in the Account_Util function files so we only have one version of each.For ex,
    
    void display(const std::vector < Account*> &accounts);
    void deposit(const std::vector < Account*> &accounts,double amount);
    void withdraw(const std::vector < Account*> &accounts, double amount);
    
    Note that the vector is a vector of pointers to Account objects <Account*>
    This is what we need for dynamic polymorphism
    
  4. Test your code with base class pointers as well as local object.
  
    



